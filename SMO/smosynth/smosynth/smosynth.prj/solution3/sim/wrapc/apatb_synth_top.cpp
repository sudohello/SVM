// ==============================================================
// File generated by Vivado(TM) HLS - High-Level Synthesis from C, C++ and SystemC
// Version: 2015.1
// Copyright (C) 2015 Xilinx Inc. All rights reserved.
// ==============================================================

#include <systemc>
#include <iostream>
#include <cstdlib>
#include <cstddef>
#include <stdint.h>
#include "SysCFileHandler.h"

using namespace std;
using namespace sc_core;
using namespace sc_dt;


// [dump_struct_tree [build_nameSpaceTree] dumpedStructList] ---------->
typedef struct {
int id;
double value;
}  feature;
typedef feature Feature;


// [dump_enumeration [get_enumeration_list]] ---------->


// wrapc file define: "example_0_id"
#define AUTOTB_TVIN_example_0_id  "../tv/cdatafile/c.synth_top.autotvin_example_0_id.dat"
// wrapc file define: "example_1_id"
#define AUTOTB_TVIN_example_1_id  "../tv/cdatafile/c.synth_top.autotvin_example_1_id.dat"
// wrapc file define: "example_2_id"
#define AUTOTB_TVIN_example_2_id  "../tv/cdatafile/c.synth_top.autotvin_example_2_id.dat"
// wrapc file define: "example_3_id"
#define AUTOTB_TVIN_example_3_id  "../tv/cdatafile/c.synth_top.autotvin_example_3_id.dat"
// wrapc file define: "example_0_value"
#define AUTOTB_TVIN_example_0_value  "../tv/cdatafile/c.synth_top.autotvin_example_0_value.dat"
// wrapc file define: "example_1_value"
#define AUTOTB_TVIN_example_1_value  "../tv/cdatafile/c.synth_top.autotvin_example_1_value.dat"
// wrapc file define: "example_2_value"
#define AUTOTB_TVIN_example_2_value  "../tv/cdatafile/c.synth_top.autotvin_example_2_value.dat"
// wrapc file define: "example_3_value"
#define AUTOTB_TVIN_example_3_value  "../tv/cdatafile/c.synth_top.autotvin_example_3_value.dat"
// wrapc file define: "sv_0_id"
#define AUTOTB_TVIN_sv_0_id  "../tv/cdatafile/c.synth_top.autotvin_sv_0_id.dat"
// wrapc file define: "sv_1_id"
#define AUTOTB_TVIN_sv_1_id  "../tv/cdatafile/c.synth_top.autotvin_sv_1_id.dat"
// wrapc file define: "sv_2_id"
#define AUTOTB_TVIN_sv_2_id  "../tv/cdatafile/c.synth_top.autotvin_sv_2_id.dat"
// wrapc file define: "sv_3_id"
#define AUTOTB_TVIN_sv_3_id  "../tv/cdatafile/c.synth_top.autotvin_sv_3_id.dat"
// wrapc file define: "sv_0_value"
#define AUTOTB_TVIN_sv_0_value  "../tv/cdatafile/c.synth_top.autotvin_sv_0_value.dat"
// wrapc file define: "sv_1_value"
#define AUTOTB_TVIN_sv_1_value  "../tv/cdatafile/c.synth_top.autotvin_sv_1_value.dat"
// wrapc file define: "sv_2_value"
#define AUTOTB_TVIN_sv_2_value  "../tv/cdatafile/c.synth_top.autotvin_sv_2_value.dat"
// wrapc file define: "sv_3_value"
#define AUTOTB_TVIN_sv_3_value  "../tv/cdatafile/c.synth_top.autotvin_sv_3_value.dat"
// wrapc file define: "lambda"
#define AUTOTB_TVIN_lambda  "../tv/cdatafile/c.synth_top.autotvin_lambda.dat"
// wrapc file define: "svNonZeroFeature"
#define AUTOTB_TVIN_svNonZeroFeature  "../tv/cdatafile/c.synth_top.autotvin_svNonZeroFeature.dat"
// wrapc file define: "nonZeroFeature"
#define AUTOTB_TVIN_nonZeroFeature  "../tv/cdatafile/c.synth_top.autotvin_nonZeroFeature.dat"
// wrapc file define: "weight"
#define AUTOTB_TVIN_weight  "../tv/cdatafile/c.synth_top.autotvin_weight.dat"
// wrapc file define: "output_r"
#define AUTOTB_TVIN_output_r  "../tv/cdatafile/c.synth_top.autotvin_output_r.dat"
#define AUTOTB_TVOUT_output_r  "../tv/cdatafile/c.synth_top.autotvout_output_r.dat"
// wrapc file define: "kernelType"
#define AUTOTB_TVIN_kernelType  "../tv/cdatafile/c.synth_top.autotvin_kernelType.dat"
// wrapc file define: "ap_return"
#define AUTOTB_TVOUT_ap_return  "../tv/cdatafile/c.synth_top.autotvout_ap_return.dat"

#define INTER_TCL  "../tv/cdatafile/ref.tcl"

// tvout file define: "output_r"
#define AUTOTB_TVOUT_PC_output_r  "../tv/rtldatafile/rtl.synth_top.autotvout_output_r.dat"
// tvout file define: "ap_return"
#define AUTOTB_TVOUT_PC_ap_return  "../tv/rtldatafile/rtl.synth_top.autotvout_ap_return.dat"

class INTER_TCL_FILE {
	public:
		INTER_TCL_FILE(const char* name) {
			mName = name;
			example_0_id_depth = 0;
			example_1_id_depth = 0;
			example_2_id_depth = 0;
			example_3_id_depth = 0;
			example_0_value_depth = 0;
			example_1_value_depth = 0;
			example_2_value_depth = 0;
			example_3_value_depth = 0;
			sv_0_id_depth = 0;
			sv_1_id_depth = 0;
			sv_2_id_depth = 0;
			sv_3_id_depth = 0;
			sv_0_value_depth = 0;
			sv_1_value_depth = 0;
			sv_2_value_depth = 0;
			sv_3_value_depth = 0;
			lambda_depth = 0;
			svNonZeroFeature_depth = 0;
			nonZeroFeature_depth = 0;
			weight_depth = 0;
			output_r_depth = 0;
			kernelType_depth = 0;
			ap_return_depth = 0;
			trans_num =0;
		}

		~INTER_TCL_FILE() {
			mFile.open(mName);
			if (!mFile.good()) {
				cout << "Failed to open file ref.tcl" << endl;
				exit (1);
			}
			string total_list = get_depth_list();
			mFile << "set depth_list {\n";
			mFile << total_list;
			mFile << "}\n";
			mFile << "set trans_num "<<trans_num<<endl;
			mFile.close();
		}

		string get_depth_list () {
			stringstream total_list;
			total_list << "{example_0_id " << example_0_id_depth << "}\n";
			total_list << "{example_1_id " << example_1_id_depth << "}\n";
			total_list << "{example_2_id " << example_2_id_depth << "}\n";
			total_list << "{example_3_id " << example_3_id_depth << "}\n";
			total_list << "{example_0_value " << example_0_value_depth << "}\n";
			total_list << "{example_1_value " << example_1_value_depth << "}\n";
			total_list << "{example_2_value " << example_2_value_depth << "}\n";
			total_list << "{example_3_value " << example_3_value_depth << "}\n";
			total_list << "{sv_0_id " << sv_0_id_depth << "}\n";
			total_list << "{sv_1_id " << sv_1_id_depth << "}\n";
			total_list << "{sv_2_id " << sv_2_id_depth << "}\n";
			total_list << "{sv_3_id " << sv_3_id_depth << "}\n";
			total_list << "{sv_0_value " << sv_0_value_depth << "}\n";
			total_list << "{sv_1_value " << sv_1_value_depth << "}\n";
			total_list << "{sv_2_value " << sv_2_value_depth << "}\n";
			total_list << "{sv_3_value " << sv_3_value_depth << "}\n";
			total_list << "{lambda " << lambda_depth << "}\n";
			total_list << "{svNonZeroFeature " << svNonZeroFeature_depth << "}\n";
			total_list << "{nonZeroFeature " << nonZeroFeature_depth << "}\n";
			total_list << "{weight " << weight_depth << "}\n";
			total_list << "{output_r " << output_r_depth << "}\n";
			total_list << "{kernelType " << kernelType_depth << "}\n";
			total_list << "{ap_return " << ap_return_depth << "}\n";
			return total_list.str();
		}

		void set_num (int num , int* class_num) {
			(*class_num) = (*class_num) > num ? (*class_num) : num;
		}
	public:
		int example_0_id_depth;
		int example_1_id_depth;
		int example_2_id_depth;
		int example_3_id_depth;
		int example_0_value_depth;
		int example_1_value_depth;
		int example_2_value_depth;
		int example_3_value_depth;
		int sv_0_id_depth;
		int sv_1_id_depth;
		int sv_2_id_depth;
		int sv_3_id_depth;
		int sv_0_value_depth;
		int sv_1_value_depth;
		int sv_2_value_depth;
		int sv_3_value_depth;
		int lambda_depth;
		int svNonZeroFeature_depth;
		int nonZeroFeature_depth;
		int weight_depth;
		int output_r_depth;
		int kernelType_depth;
		int ap_return_depth;
		int trans_num;

	private:
		ofstream mFile;
		const char* mName;
};

extern "C" int synth_top (Feature example[4][50], Feature sv[17][50], double lambda[17], int svNonZeroFeature[17], int nonZeroFeature[4], double weight[49], double output[4], int kernelType);

#define synth_top AESL_ORIG_DUT_synth_top
extern "C" int synth_top (Feature example[4][50], Feature sv[17][50], double lambda[17], int svNonZeroFeature[17], int nonZeroFeature[4], double weight[49], double output[4], int kernelType);
#undef synth_top

int synth_top (Feature example[4][50], Feature sv[17][50], double lambda[17], int svNonZeroFeature[17], int nonZeroFeature[4], double weight[49], double output[4], int kernelType)
{
	fstream wrapc_switch_file_token;
	wrapc_switch_file_token.open(".hls_cosim_wrapc_switch.log");
	int AESL_i;
	if (wrapc_switch_file_token.good())
	{
		static unsigned AESL_transaction_pc = 0;
		string AESL_token;
		string AESL_num;
		static AESL_FILE_HANDLER aesl_fh;

		int AESL_return;

		// output port post check: "output_r"
		aesl_fh.read(AUTOTB_TVOUT_PC_output_r, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_output_r, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_output_r, AESL_token); // data

			sc_bv<64> *output_r_pc_buffer = new sc_bv<64>[4];
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'output_r', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'output_r', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					output_r_pc_buffer[i] = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_output_r, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_output_r))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				sc_lv<64>* output_lv0_0_3_1 = new sc_lv<64>[4];
				AESL_i = 0;
				for (int i_0 = 0; i_0 <= 3; i_0 += 1)
				{
					if (&(output[0]) != NULL)
					{
						output_lv0_0_3_1[0 + AESL_i].range(63, 0) = sc_bv<64>(output_r_pc_buffer[0 + AESL_i].range(63, 0));
					}

					AESL_i++;
				}
				AESL_i = 0;

				for (int i_0 = 0; i_0 <= 3; i_0 += 1)
				{

					if (&(output[0]) != NULL)
					{
						*(long long*)&output[i_0] = (output_lv0_0_3_1[0 + AESL_i]).to_uint64();
					}

					AESL_i++;
				}
			}

			// release memory allocation
			delete [] output_r_pc_buffer;
		}

		// output port post check: "ap_return"
		aesl_fh.read(AUTOTB_TVOUT_PC_ap_return, AESL_token); // [[transaction]]
		if (AESL_token != "[[transaction]]")
		{
			exit(1);
		}
		aesl_fh.read(AUTOTB_TVOUT_PC_ap_return, AESL_num); // transaction number

		if (atoi(AESL_num.c_str()) == AESL_transaction_pc)
		{
			aesl_fh.read(AUTOTB_TVOUT_PC_ap_return, AESL_token); // data

			sc_bv<32> ap_return_pc_buffer;
			int i = 0;

			while (AESL_token != "[[/transaction]]")
			{
				bool no_x = false;
				bool err = false;

				// search and replace 'X' with "0" from the 1st char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('X');
					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'ap_return', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				no_x = false;

				// search and replace 'x' with "0" from the 3rd char of token
				while (!no_x)
				{
					size_t x_found = AESL_token.find('x', 2);

					if (x_found != string::npos)
					{
						if (!err)
						{
							cerr << "@W [SIM-201] RTL produces unknown value 'X' on port 'ap_return', possible cause: There are uninitialized variables in the C design." << endl;
							err = true;
						}
						AESL_token.replace(x_found, 1, "0");
					}
					else
					{
						no_x = true;
					}
				}

				// push token into output port buffer
				if (AESL_token != "")
				{
					ap_return_pc_buffer = AESL_token.c_str();
					i++;
				}

				aesl_fh.read(AUTOTB_TVOUT_PC_ap_return, AESL_token); // data or [[/transaction]]

				if (AESL_token == "[[[/runtime]]]" || aesl_fh.eof(AUTOTB_TVOUT_PC_ap_return))
				{
					exit(1);
				}
			}

			// ***********************************
			if (i > 0)
			{
				sc_lv<32> return_lv0_0_1_0;
				AESL_i = 0;
					if (&(AESL_return) != NULL)
					{
						return_lv0_0_1_0.range(31, 0) = sc_bv<32>(ap_return_pc_buffer.range(31, 0));
					}

					AESL_i++;
				AESL_i = 0;

					if (&(AESL_return) != NULL)
					{
						AESL_return = (return_lv0_0_1_0).to_uint64();
					}

					AESL_i++;
			}
		}

		AESL_transaction_pc++;

		return AESL_return;
	}
	else
	{
		static unsigned AESL_transaction;

		static AESL_FILE_HANDLER aesl_fh;

		// "example_0_id"
		char* tvin_example_0_id = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_example_0_id);

		// "example_1_id"
		char* tvin_example_1_id = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_example_1_id);

		// "example_2_id"
		char* tvin_example_2_id = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_example_2_id);

		// "example_3_id"
		char* tvin_example_3_id = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_example_3_id);

		// "example_0_value"
		char* tvin_example_0_value = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_example_0_value);

		// "example_1_value"
		char* tvin_example_1_value = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_example_1_value);

		// "example_2_value"
		char* tvin_example_2_value = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_example_2_value);

		// "example_3_value"
		char* tvin_example_3_value = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_example_3_value);

		// "sv_0_id"
		char* tvin_sv_0_id = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_sv_0_id);

		// "sv_1_id"
		char* tvin_sv_1_id = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_sv_1_id);

		// "sv_2_id"
		char* tvin_sv_2_id = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_sv_2_id);

		// "sv_3_id"
		char* tvin_sv_3_id = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_sv_3_id);

		// "sv_0_value"
		char* tvin_sv_0_value = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_sv_0_value);

		// "sv_1_value"
		char* tvin_sv_1_value = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_sv_1_value);

		// "sv_2_value"
		char* tvin_sv_2_value = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_sv_2_value);

		// "sv_3_value"
		char* tvin_sv_3_value = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_sv_3_value);

		// "lambda"
		char* tvin_lambda = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_lambda);

		// "svNonZeroFeature"
		char* tvin_svNonZeroFeature = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_svNonZeroFeature);

		// "nonZeroFeature"
		char* tvin_nonZeroFeature = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_nonZeroFeature);

		// "weight"
		char* tvin_weight = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_weight);

		// "output_r"
		char* tvin_output_r = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_output_r);
		char* tvout_output_r = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_output_r);

		// "kernelType"
		char* tvin_kernelType = new char[50];
		aesl_fh.touch(AUTOTB_TVIN_kernelType);

		// "ap_return"
		char* tvout_ap_return = new char[50];
		aesl_fh.touch(AUTOTB_TVOUT_ap_return);

		static INTER_TCL_FILE tcl_file(INTER_TCL);
		int leading_zero;

		// [[transaction]]
		sprintf(tvin_example_0_id, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_example_0_id, tvin_example_0_id);

		sc_bv<32>* example_0_id_tvin_wrapc_buffer = new sc_bv<32>[52];

		// Name: example_0_id
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: example.id(31, 0)
				{
					// carray: (0) => (3) @ (1)
					for (int i_0 = 0; i_0 <= 3; i_0 += 1)
					{
						// carray: (0) => (48) @ (4)
						for (int i_1 = 0; i_1 <= 48; i_1 += 4)
						{
							if (&(example[0][0].id) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<32> example_id_tmp_mem;
								example_id_tmp_mem = example[i_0][i_1].id;
								example_0_id_tvin_wrapc_buffer[hls_map_index++].range(31, 0) = example_id_tmp_mem.range(31, 0);
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 52; i++)
		{
			sprintf(tvin_example_0_id, "%s\n", (example_0_id_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_example_0_id, tvin_example_0_id);
		}

		tcl_file.set_num(52, &tcl_file.example_0_id_depth);
		sprintf(tvin_example_0_id, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_example_0_id, tvin_example_0_id);

		// release memory allocation
		delete [] example_0_id_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_example_1_id, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_example_1_id, tvin_example_1_id);

		sc_bv<32>* example_1_id_tvin_wrapc_buffer = new sc_bv<32>[52];

		// Name: example_1_id
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: example.id(31, 0)
				{
					// carray: (0) => (3) @ (1)
					for (int i_0 = 0; i_0 <= 3; i_0 += 1)
					{
						// carray: (1) => (49) @ (4)
						for (int i_1 = 1; i_1 <= 49; i_1 += 4)
						{
							if (&(example[0][0].id) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<32> example_id_tmp_mem;
								example_id_tmp_mem = example[i_0][i_1].id;
								example_1_id_tvin_wrapc_buffer[hls_map_index++].range(31, 0) = example_id_tmp_mem.range(31, 0);
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 52; i++)
		{
			sprintf(tvin_example_1_id, "%s\n", (example_1_id_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_example_1_id, tvin_example_1_id);
		}

		tcl_file.set_num(52, &tcl_file.example_1_id_depth);
		sprintf(tvin_example_1_id, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_example_1_id, tvin_example_1_id);

		// release memory allocation
		delete [] example_1_id_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_example_2_id, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_example_2_id, tvin_example_2_id);

		sc_bv<32>* example_2_id_tvin_wrapc_buffer = new sc_bv<32>[48];

		// Name: example_2_id
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: example.id(31, 0)
				{
					// carray: (0) => (3) @ (1)
					for (int i_0 = 0; i_0 <= 3; i_0 += 1)
					{
						// carray: (2) => (49) @ (4)
						for (int i_1 = 2; i_1 <= 49; i_1 += 4)
						{
							if (&(example[0][0].id) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<32> example_id_tmp_mem;
								example_id_tmp_mem = example[i_0][i_1].id;
								example_2_id_tvin_wrapc_buffer[hls_map_index++].range(31, 0) = example_id_tmp_mem.range(31, 0);
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 48; i++)
		{
			sprintf(tvin_example_2_id, "%s\n", (example_2_id_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_example_2_id, tvin_example_2_id);
		}

		tcl_file.set_num(48, &tcl_file.example_2_id_depth);
		sprintf(tvin_example_2_id, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_example_2_id, tvin_example_2_id);

		// release memory allocation
		delete [] example_2_id_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_example_3_id, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_example_3_id, tvin_example_3_id);

		sc_bv<32>* example_3_id_tvin_wrapc_buffer = new sc_bv<32>[48];

		// Name: example_3_id
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: example.id(31, 0)
				{
					// carray: (0) => (3) @ (1)
					for (int i_0 = 0; i_0 <= 3; i_0 += 1)
					{
						// carray: (3) => (49) @ (4)
						for (int i_1 = 3; i_1 <= 49; i_1 += 4)
						{
							if (&(example[0][0].id) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<32> example_id_tmp_mem;
								example_id_tmp_mem = example[i_0][i_1].id;
								example_3_id_tvin_wrapc_buffer[hls_map_index++].range(31, 0) = example_id_tmp_mem.range(31, 0);
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 48; i++)
		{
			sprintf(tvin_example_3_id, "%s\n", (example_3_id_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_example_3_id, tvin_example_3_id);
		}

		tcl_file.set_num(48, &tcl_file.example_3_id_depth);
		sprintf(tvin_example_3_id, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_example_3_id, tvin_example_3_id);

		// release memory allocation
		delete [] example_3_id_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_example_0_value, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_example_0_value, tvin_example_0_value);

		sc_bv<64>* example_0_value_tvin_wrapc_buffer = new sc_bv<64>[52];

		// Name: example_0_value
		{
			// bitslice(63, 0)
			{
				int hls_map_index = 0;
				// celement: example.value(63, 0)
				{
					// carray: (0) => (3) @ (1)
					for (int i_0 = 0; i_0 <= 3; i_0 += 1)
					{
						// carray: (0) => (48) @ (4)
						for (int i_1 = 0; i_1 <= 48; i_1 += 4)
						{
							if (&(example[0][0].value) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<64> example_value_tmp_mem;
								example_value_tmp_mem = *(long long*)&example[i_0][i_1].value;
								example_0_value_tvin_wrapc_buffer[hls_map_index++].range(63, 0) = example_value_tmp_mem.range(63, 0);
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 52; i++)
		{
			sprintf(tvin_example_0_value, "%s\n", (example_0_value_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_example_0_value, tvin_example_0_value);
		}

		tcl_file.set_num(52, &tcl_file.example_0_value_depth);
		sprintf(tvin_example_0_value, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_example_0_value, tvin_example_0_value);

		// release memory allocation
		delete [] example_0_value_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_example_1_value, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_example_1_value, tvin_example_1_value);

		sc_bv<64>* example_1_value_tvin_wrapc_buffer = new sc_bv<64>[52];

		// Name: example_1_value
		{
			// bitslice(63, 0)
			{
				int hls_map_index = 0;
				// celement: example.value(63, 0)
				{
					// carray: (0) => (3) @ (1)
					for (int i_0 = 0; i_0 <= 3; i_0 += 1)
					{
						// carray: (1) => (49) @ (4)
						for (int i_1 = 1; i_1 <= 49; i_1 += 4)
						{
							if (&(example[0][0].value) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<64> example_value_tmp_mem;
								example_value_tmp_mem = *(long long*)&example[i_0][i_1].value;
								example_1_value_tvin_wrapc_buffer[hls_map_index++].range(63, 0) = example_value_tmp_mem.range(63, 0);
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 52; i++)
		{
			sprintf(tvin_example_1_value, "%s\n", (example_1_value_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_example_1_value, tvin_example_1_value);
		}

		tcl_file.set_num(52, &tcl_file.example_1_value_depth);
		sprintf(tvin_example_1_value, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_example_1_value, tvin_example_1_value);

		// release memory allocation
		delete [] example_1_value_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_example_2_value, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_example_2_value, tvin_example_2_value);

		sc_bv<64>* example_2_value_tvin_wrapc_buffer = new sc_bv<64>[48];

		// Name: example_2_value
		{
			// bitslice(63, 0)
			{
				int hls_map_index = 0;
				// celement: example.value(63, 0)
				{
					// carray: (0) => (3) @ (1)
					for (int i_0 = 0; i_0 <= 3; i_0 += 1)
					{
						// carray: (2) => (49) @ (4)
						for (int i_1 = 2; i_1 <= 49; i_1 += 4)
						{
							if (&(example[0][0].value) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<64> example_value_tmp_mem;
								example_value_tmp_mem = *(long long*)&example[i_0][i_1].value;
								example_2_value_tvin_wrapc_buffer[hls_map_index++].range(63, 0) = example_value_tmp_mem.range(63, 0);
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 48; i++)
		{
			sprintf(tvin_example_2_value, "%s\n", (example_2_value_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_example_2_value, tvin_example_2_value);
		}

		tcl_file.set_num(48, &tcl_file.example_2_value_depth);
		sprintf(tvin_example_2_value, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_example_2_value, tvin_example_2_value);

		// release memory allocation
		delete [] example_2_value_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_example_3_value, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_example_3_value, tvin_example_3_value);

		sc_bv<64>* example_3_value_tvin_wrapc_buffer = new sc_bv<64>[48];

		// Name: example_3_value
		{
			// bitslice(63, 0)
			{
				int hls_map_index = 0;
				// celement: example.value(63, 0)
				{
					// carray: (0) => (3) @ (1)
					for (int i_0 = 0; i_0 <= 3; i_0 += 1)
					{
						// carray: (3) => (49) @ (4)
						for (int i_1 = 3; i_1 <= 49; i_1 += 4)
						{
							if (&(example[0][0].value) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<64> example_value_tmp_mem;
								example_value_tmp_mem = *(long long*)&example[i_0][i_1].value;
								example_3_value_tvin_wrapc_buffer[hls_map_index++].range(63, 0) = example_value_tmp_mem.range(63, 0);
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 48; i++)
		{
			sprintf(tvin_example_3_value, "%s\n", (example_3_value_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_example_3_value, tvin_example_3_value);
		}

		tcl_file.set_num(48, &tcl_file.example_3_value_depth);
		sprintf(tvin_example_3_value, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_example_3_value, tvin_example_3_value);

		// release memory allocation
		delete [] example_3_value_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_sv_0_id, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_sv_0_id, tvin_sv_0_id);

		sc_bv<32>* sv_0_id_tvin_wrapc_buffer = new sc_bv<32>[221];

		// Name: sv_0_id
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: sv.id(31, 0)
				{
					// carray: (0) => (16) @ (1)
					for (int i_0 = 0; i_0 <= 16; i_0 += 1)
					{
						// carray: (0) => (48) @ (4)
						for (int i_1 = 0; i_1 <= 48; i_1 += 4)
						{
							if (&(sv[0][0].id) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<32> sv_id_tmp_mem;
								sv_id_tmp_mem = sv[i_0][i_1].id;
								sv_0_id_tvin_wrapc_buffer[hls_map_index++].range(31, 0) = sv_id_tmp_mem.range(31, 0);
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 221; i++)
		{
			sprintf(tvin_sv_0_id, "%s\n", (sv_0_id_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_sv_0_id, tvin_sv_0_id);
		}

		tcl_file.set_num(221, &tcl_file.sv_0_id_depth);
		sprintf(tvin_sv_0_id, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_sv_0_id, tvin_sv_0_id);

		// release memory allocation
		delete [] sv_0_id_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_sv_1_id, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_sv_1_id, tvin_sv_1_id);

		sc_bv<32>* sv_1_id_tvin_wrapc_buffer = new sc_bv<32>[221];

		// Name: sv_1_id
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: sv.id(31, 0)
				{
					// carray: (0) => (16) @ (1)
					for (int i_0 = 0; i_0 <= 16; i_0 += 1)
					{
						// carray: (1) => (49) @ (4)
						for (int i_1 = 1; i_1 <= 49; i_1 += 4)
						{
							if (&(sv[0][0].id) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<32> sv_id_tmp_mem;
								sv_id_tmp_mem = sv[i_0][i_1].id;
								sv_1_id_tvin_wrapc_buffer[hls_map_index++].range(31, 0) = sv_id_tmp_mem.range(31, 0);
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 221; i++)
		{
			sprintf(tvin_sv_1_id, "%s\n", (sv_1_id_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_sv_1_id, tvin_sv_1_id);
		}

		tcl_file.set_num(221, &tcl_file.sv_1_id_depth);
		sprintf(tvin_sv_1_id, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_sv_1_id, tvin_sv_1_id);

		// release memory allocation
		delete [] sv_1_id_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_sv_2_id, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_sv_2_id, tvin_sv_2_id);

		sc_bv<32>* sv_2_id_tvin_wrapc_buffer = new sc_bv<32>[204];

		// Name: sv_2_id
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: sv.id(31, 0)
				{
					// carray: (0) => (16) @ (1)
					for (int i_0 = 0; i_0 <= 16; i_0 += 1)
					{
						// carray: (2) => (49) @ (4)
						for (int i_1 = 2; i_1 <= 49; i_1 += 4)
						{
							if (&(sv[0][0].id) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<32> sv_id_tmp_mem;
								sv_id_tmp_mem = sv[i_0][i_1].id;
								sv_2_id_tvin_wrapc_buffer[hls_map_index++].range(31, 0) = sv_id_tmp_mem.range(31, 0);
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 204; i++)
		{
			sprintf(tvin_sv_2_id, "%s\n", (sv_2_id_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_sv_2_id, tvin_sv_2_id);
		}

		tcl_file.set_num(204, &tcl_file.sv_2_id_depth);
		sprintf(tvin_sv_2_id, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_sv_2_id, tvin_sv_2_id);

		// release memory allocation
		delete [] sv_2_id_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_sv_3_id, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_sv_3_id, tvin_sv_3_id);

		sc_bv<32>* sv_3_id_tvin_wrapc_buffer = new sc_bv<32>[204];

		// Name: sv_3_id
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: sv.id(31, 0)
				{
					// carray: (0) => (16) @ (1)
					for (int i_0 = 0; i_0 <= 16; i_0 += 1)
					{
						// carray: (3) => (49) @ (4)
						for (int i_1 = 3; i_1 <= 49; i_1 += 4)
						{
							if (&(sv[0][0].id) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<32> sv_id_tmp_mem;
								sv_id_tmp_mem = sv[i_0][i_1].id;
								sv_3_id_tvin_wrapc_buffer[hls_map_index++].range(31, 0) = sv_id_tmp_mem.range(31, 0);
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 204; i++)
		{
			sprintf(tvin_sv_3_id, "%s\n", (sv_3_id_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_sv_3_id, tvin_sv_3_id);
		}

		tcl_file.set_num(204, &tcl_file.sv_3_id_depth);
		sprintf(tvin_sv_3_id, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_sv_3_id, tvin_sv_3_id);

		// release memory allocation
		delete [] sv_3_id_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_sv_0_value, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_sv_0_value, tvin_sv_0_value);

		sc_bv<64>* sv_0_value_tvin_wrapc_buffer = new sc_bv<64>[221];

		// Name: sv_0_value
		{
			// bitslice(63, 0)
			{
				int hls_map_index = 0;
				// celement: sv.value(63, 0)
				{
					// carray: (0) => (16) @ (1)
					for (int i_0 = 0; i_0 <= 16; i_0 += 1)
					{
						// carray: (0) => (48) @ (4)
						for (int i_1 = 0; i_1 <= 48; i_1 += 4)
						{
							if (&(sv[0][0].value) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<64> sv_value_tmp_mem;
								sv_value_tmp_mem = *(long long*)&sv[i_0][i_1].value;
								sv_0_value_tvin_wrapc_buffer[hls_map_index++].range(63, 0) = sv_value_tmp_mem.range(63, 0);
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 221; i++)
		{
			sprintf(tvin_sv_0_value, "%s\n", (sv_0_value_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_sv_0_value, tvin_sv_0_value);
		}

		tcl_file.set_num(221, &tcl_file.sv_0_value_depth);
		sprintf(tvin_sv_0_value, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_sv_0_value, tvin_sv_0_value);

		// release memory allocation
		delete [] sv_0_value_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_sv_1_value, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_sv_1_value, tvin_sv_1_value);

		sc_bv<64>* sv_1_value_tvin_wrapc_buffer = new sc_bv<64>[221];

		// Name: sv_1_value
		{
			// bitslice(63, 0)
			{
				int hls_map_index = 0;
				// celement: sv.value(63, 0)
				{
					// carray: (0) => (16) @ (1)
					for (int i_0 = 0; i_0 <= 16; i_0 += 1)
					{
						// carray: (1) => (49) @ (4)
						for (int i_1 = 1; i_1 <= 49; i_1 += 4)
						{
							if (&(sv[0][0].value) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<64> sv_value_tmp_mem;
								sv_value_tmp_mem = *(long long*)&sv[i_0][i_1].value;
								sv_1_value_tvin_wrapc_buffer[hls_map_index++].range(63, 0) = sv_value_tmp_mem.range(63, 0);
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 221; i++)
		{
			sprintf(tvin_sv_1_value, "%s\n", (sv_1_value_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_sv_1_value, tvin_sv_1_value);
		}

		tcl_file.set_num(221, &tcl_file.sv_1_value_depth);
		sprintf(tvin_sv_1_value, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_sv_1_value, tvin_sv_1_value);

		// release memory allocation
		delete [] sv_1_value_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_sv_2_value, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_sv_2_value, tvin_sv_2_value);

		sc_bv<64>* sv_2_value_tvin_wrapc_buffer = new sc_bv<64>[204];

		// Name: sv_2_value
		{
			// bitslice(63, 0)
			{
				int hls_map_index = 0;
				// celement: sv.value(63, 0)
				{
					// carray: (0) => (16) @ (1)
					for (int i_0 = 0; i_0 <= 16; i_0 += 1)
					{
						// carray: (2) => (49) @ (4)
						for (int i_1 = 2; i_1 <= 49; i_1 += 4)
						{
							if (&(sv[0][0].value) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<64> sv_value_tmp_mem;
								sv_value_tmp_mem = *(long long*)&sv[i_0][i_1].value;
								sv_2_value_tvin_wrapc_buffer[hls_map_index++].range(63, 0) = sv_value_tmp_mem.range(63, 0);
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 204; i++)
		{
			sprintf(tvin_sv_2_value, "%s\n", (sv_2_value_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_sv_2_value, tvin_sv_2_value);
		}

		tcl_file.set_num(204, &tcl_file.sv_2_value_depth);
		sprintf(tvin_sv_2_value, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_sv_2_value, tvin_sv_2_value);

		// release memory allocation
		delete [] sv_2_value_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_sv_3_value, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_sv_3_value, tvin_sv_3_value);

		sc_bv<64>* sv_3_value_tvin_wrapc_buffer = new sc_bv<64>[204];

		// Name: sv_3_value
		{
			// bitslice(63, 0)
			{
				int hls_map_index = 0;
				// celement: sv.value(63, 0)
				{
					// carray: (0) => (16) @ (1)
					for (int i_0 = 0; i_0 <= 16; i_0 += 1)
					{
						// carray: (3) => (49) @ (4)
						for (int i_1 = 3; i_1 <= 49; i_1 += 4)
						{
							if (&(sv[0][0].value) != NULL) // check the null address if the c port is array or others
							{
								sc_lv<64> sv_value_tmp_mem;
								sv_value_tmp_mem = *(long long*)&sv[i_0][i_1].value;
								sv_3_value_tvin_wrapc_buffer[hls_map_index++].range(63, 0) = sv_value_tmp_mem.range(63, 0);
							}
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 204; i++)
		{
			sprintf(tvin_sv_3_value, "%s\n", (sv_3_value_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_sv_3_value, tvin_sv_3_value);
		}

		tcl_file.set_num(204, &tcl_file.sv_3_value_depth);
		sprintf(tvin_sv_3_value, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_sv_3_value, tvin_sv_3_value);

		// release memory allocation
		delete [] sv_3_value_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_lambda, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_lambda, tvin_lambda);

		sc_bv<64>* lambda_tvin_wrapc_buffer = new sc_bv<64>[17];

		// Name: lambda
		{
			// bitslice(63, 0)
			{
				int hls_map_index = 0;
				// celement: lambda(63, 0)
				{
					// carray: (0) => (16) @ (1)
					for (int i_0 = 0; i_0 <= 16; i_0 += 1)
					{
						if (&(lambda[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<64> lambda_tmp_mem;
							lambda_tmp_mem = *(long long*)&lambda[i_0];
							lambda_tvin_wrapc_buffer[hls_map_index++].range(63, 0) = lambda_tmp_mem.range(63, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 17; i++)
		{
			sprintf(tvin_lambda, "%s\n", (lambda_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_lambda, tvin_lambda);
		}

		tcl_file.set_num(17, &tcl_file.lambda_depth);
		sprintf(tvin_lambda, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_lambda, tvin_lambda);

		// release memory allocation
		delete [] lambda_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_svNonZeroFeature, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_svNonZeroFeature, tvin_svNonZeroFeature);

		sc_bv<32>* svNonZeroFeature_tvin_wrapc_buffer = new sc_bv<32>[17];

		// Name: svNonZeroFeature
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: svNonZeroFeature(31, 0)
				{
					// carray: (0) => (16) @ (1)
					for (int i_0 = 0; i_0 <= 16; i_0 += 1)
					{
						if (&(svNonZeroFeature[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> svNonZeroFeature_tmp_mem;
							svNonZeroFeature_tmp_mem = svNonZeroFeature[i_0];
							svNonZeroFeature_tvin_wrapc_buffer[hls_map_index++].range(31, 0) = svNonZeroFeature_tmp_mem.range(31, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 17; i++)
		{
			sprintf(tvin_svNonZeroFeature, "%s\n", (svNonZeroFeature_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_svNonZeroFeature, tvin_svNonZeroFeature);
		}

		tcl_file.set_num(17, &tcl_file.svNonZeroFeature_depth);
		sprintf(tvin_svNonZeroFeature, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_svNonZeroFeature, tvin_svNonZeroFeature);

		// release memory allocation
		delete [] svNonZeroFeature_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_nonZeroFeature, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_nonZeroFeature, tvin_nonZeroFeature);

		sc_bv<32>* nonZeroFeature_tvin_wrapc_buffer = new sc_bv<32>[4];

		// Name: nonZeroFeature
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: nonZeroFeature(31, 0)
				{
					// carray: (0) => (3) @ (1)
					for (int i_0 = 0; i_0 <= 3; i_0 += 1)
					{
						if (&(nonZeroFeature[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<32> nonZeroFeature_tmp_mem;
							nonZeroFeature_tmp_mem = nonZeroFeature[i_0];
							nonZeroFeature_tvin_wrapc_buffer[hls_map_index++].range(31, 0) = nonZeroFeature_tmp_mem.range(31, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 4; i++)
		{
			sprintf(tvin_nonZeroFeature, "%s\n", (nonZeroFeature_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_nonZeroFeature, tvin_nonZeroFeature);
		}

		tcl_file.set_num(4, &tcl_file.nonZeroFeature_depth);
		sprintf(tvin_nonZeroFeature, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_nonZeroFeature, tvin_nonZeroFeature);

		// release memory allocation
		delete [] nonZeroFeature_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_weight, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_weight, tvin_weight);

		sc_bv<64>* weight_tvin_wrapc_buffer = new sc_bv<64>[49];

		// Name: weight
		{
			// bitslice(63, 0)
			{
				int hls_map_index = 0;
				// celement: weight(63, 0)
				{
					// carray: (0) => (48) @ (1)
					for (int i_0 = 0; i_0 <= 48; i_0 += 1)
					{
						if (&(weight[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<64> weight_tmp_mem;
							weight_tmp_mem = *(long long*)&weight[i_0];
							weight_tvin_wrapc_buffer[hls_map_index++].range(63, 0) = weight_tmp_mem.range(63, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 49; i++)
		{
			sprintf(tvin_weight, "%s\n", (weight_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_weight, tvin_weight);
		}

		tcl_file.set_num(49, &tcl_file.weight_depth);
		sprintf(tvin_weight, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_weight, tvin_weight);

		// release memory allocation
		delete [] weight_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_output_r, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_output_r, tvin_output_r);

		sc_bv<64>* output_r_tvin_wrapc_buffer = new sc_bv<64>[4];

		// Name: output_r
		{
			// bitslice(63, 0)
			{
				int hls_map_index = 0;
				// celement: output(63, 0)
				{
					// carray: (0) => (3) @ (1)
					for (int i_0 = 0; i_0 <= 3; i_0 += 1)
					{
						if (&(output[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<64> output_tmp_mem;
							output_tmp_mem = *(long long*)&output[i_0];
							output_r_tvin_wrapc_buffer[hls_map_index++].range(63, 0) = output_tmp_mem.range(63, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 4; i++)
		{
			sprintf(tvin_output_r, "%s\n", (output_r_tvin_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_output_r, tvin_output_r);
		}

		tcl_file.set_num(4, &tcl_file.output_r_depth);
		sprintf(tvin_output_r, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_output_r, tvin_output_r);

		// release memory allocation
		delete [] output_r_tvin_wrapc_buffer;

		// [[transaction]]
		sprintf(tvin_kernelType, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVIN_kernelType, tvin_kernelType);

		sc_bv<32> kernelType_tvin_wrapc_buffer;

		// Name: kernelType
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: kernelType(31, 0)
				{
					// carray: (0) => (0) @ (0)
					if (&(kernelType) != NULL) // check the null address if the c port is array or others
					{
						sc_lv<32> kernelType_tmp_mem;
						kernelType_tmp_mem = kernelType;
						kernelType_tvin_wrapc_buffer.range(31, 0) = kernelType_tmp_mem.range(31, 0);
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvin_kernelType, "%s\n", (kernelType_tvin_wrapc_buffer).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVIN_kernelType, tvin_kernelType);
		}

		tcl_file.set_num(1, &tcl_file.kernelType_depth);
		sprintf(tvin_kernelType, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVIN_kernelType, tvin_kernelType);

// [call_c_dut] ---------->

		int AESL_return = AESL_ORIG_DUT_synth_top(example, sv, lambda, svNonZeroFeature, nonZeroFeature, weight, output, kernelType);


		// [[transaction]]
		sprintf(tvout_output_r, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_output_r, tvout_output_r);

		sc_bv<64>* output_r_tvout_wrapc_buffer = new sc_bv<64>[4];

		// Name: output_r
		{
			// bitslice(63, 0)
			{
				int hls_map_index = 0;
				// celement: output(63, 0)
				{
					// carray: (0) => (3) @ (1)
					for (int i_0 = 0; i_0 <= 3; i_0 += 1)
					{
						if (&(output[0]) != NULL) // check the null address if the c port is array or others
						{
							sc_lv<64> output_tmp_mem;
							output_tmp_mem = *(long long*)&output[i_0];
							output_r_tvout_wrapc_buffer[hls_map_index++].range(63, 0) = output_tmp_mem.range(63, 0);
						}
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 4; i++)
		{
			sprintf(tvout_output_r, "%s\n", (output_r_tvout_wrapc_buffer[i]).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_output_r, tvout_output_r);
		}

		tcl_file.set_num(4, &tcl_file.output_r_depth);
		sprintf(tvout_output_r, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_output_r, tvout_output_r);

		// release memory allocation
		delete [] output_r_tvout_wrapc_buffer;

		// [[transaction]]
		sprintf(tvout_ap_return, "[[transaction]] %d\n", AESL_transaction);
		aesl_fh.write(AUTOTB_TVOUT_ap_return, tvout_ap_return);

		sc_bv<32> ap_return_tvout_wrapc_buffer;

		// Name: ap_return
		{
			// bitslice(31, 0)
			{
				int hls_map_index = 0;
				// celement: return(31, 0)
				{
					// carray: (0) => (1) @ (0)
					if (&(AESL_return) != NULL) // check the null address if the c port is array or others
					{
						sc_lv<32> return_tmp_mem;
						return_tmp_mem = AESL_return;
						ap_return_tvout_wrapc_buffer.range(31, 0) = return_tmp_mem.range(31, 0);
					}
				}
			}
		}

		// dump tv to file
		for (int i = 0; i < 1; i++)
		{
			sprintf(tvout_ap_return, "%s\n", (ap_return_tvout_wrapc_buffer).to_string(SC_HEX).c_str());
			aesl_fh.write(AUTOTB_TVOUT_ap_return, tvout_ap_return);
		}

		tcl_file.set_num(1, &tcl_file.ap_return_depth);
		sprintf(tvout_ap_return, "[[/transaction]] \n");
		aesl_fh.write(AUTOTB_TVOUT_ap_return, tvout_ap_return);

		// release memory allocation: "example_0_id"
		delete [] tvin_example_0_id;
		// release memory allocation: "example_1_id"
		delete [] tvin_example_1_id;
		// release memory allocation: "example_2_id"
		delete [] tvin_example_2_id;
		// release memory allocation: "example_3_id"
		delete [] tvin_example_3_id;
		// release memory allocation: "example_0_value"
		delete [] tvin_example_0_value;
		// release memory allocation: "example_1_value"
		delete [] tvin_example_1_value;
		// release memory allocation: "example_2_value"
		delete [] tvin_example_2_value;
		// release memory allocation: "example_3_value"
		delete [] tvin_example_3_value;
		// release memory allocation: "sv_0_id"
		delete [] tvin_sv_0_id;
		// release memory allocation: "sv_1_id"
		delete [] tvin_sv_1_id;
		// release memory allocation: "sv_2_id"
		delete [] tvin_sv_2_id;
		// release memory allocation: "sv_3_id"
		delete [] tvin_sv_3_id;
		// release memory allocation: "sv_0_value"
		delete [] tvin_sv_0_value;
		// release memory allocation: "sv_1_value"
		delete [] tvin_sv_1_value;
		// release memory allocation: "sv_2_value"
		delete [] tvin_sv_2_value;
		// release memory allocation: "sv_3_value"
		delete [] tvin_sv_3_value;
		// release memory allocation: "lambda"
		delete [] tvin_lambda;
		// release memory allocation: "svNonZeroFeature"
		delete [] tvin_svNonZeroFeature;
		// release memory allocation: "nonZeroFeature"
		delete [] tvin_nonZeroFeature;
		// release memory allocation: "weight"
		delete [] tvin_weight;
		// release memory allocation: "output_r"
		delete [] tvin_output_r;
		delete [] tvout_output_r;
		// release memory allocation: "kernelType"
		delete [] tvin_kernelType;
		// release memory allocation: "ap_return"
		delete [] tvout_ap_return;

		AESL_transaction++;

		tcl_file.set_num(AESL_transaction , &tcl_file.trans_num);

		return AESL_return;
	}
}

